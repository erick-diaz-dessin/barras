<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>División de Números</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>División de Números</h1>
        <div class="form-group">
            <label for="num1">Distancia:</label>
            <input type="number" id="num1" placeholder="Ingrese distancia">
        </div>
        <div class="form-group">
            <label for="num2">Barras:</label>
            <input type="number" id="num2" placeholder="Ingrese barras">
        </div>
        <div class="form-group">
            <label for="num3">Espesor:</label>
            <input type="number" id="num3" placeholder="Ingrese espesor">
        </div>
        <div class="form-group">
            <label for="num4">Ángulo (grados):</label>
            <input type="number" id="num4" placeholder="Ingrese ángulo">
        </div>
        <form id="button-container">
            <label>
              <input type="radio" name="lado" value="izquierda" onchange="updateTable(this)">
              <img class="lado-img" src="img/barra-izq-removebg-preview.png" alt="Texto alternativo" width="32" height="32">
              <div>a la izquierda <br> de la barra</div>  
            </label><br>
            <label>
              <input type="radio" name="lado" value="centro" onchange="updateTable(this)" checked>
              <img class="lado-img" src="img/barra-cen-removebg-preview.png" alt="Texto alternativo" width="32" height="32">
              <div>al centro <br> de la barra</div>  
            </label><br>
            <label>
              <input type="radio" name="lado" value="derecha" onchange="updateTable(this)">
              <img class="lado-img" src="img/barra-der-removebg-preview.png" alt="Texto alternativo" width="32" height="32">
              <div>a la derecha <br> de la barra</div>  
            </label>
          </form>
        <button onclick="calculate()" id="main-button">Dividir</button>
        <p id="result"></p>
        <button id="boton-ocultar" onclick="toggleLimites()">Mostrar/Ocultar Info</button>
        
    </div>
    <br>
    <div id="visor-3d" style="width: 100%; height: 80vh; display: none;"></div>
    <script src="script.js"></script>

    <!-- este bloque muestra las barras 3D -->
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js?module';
      import { FontLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/FontLoader.js?module';
      import { TextGeometry } from 'https://unpkg.com/three@0.161.0/examples/jsm/geometries/TextGeometry.js?module';

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0); // Fondo claro tipo SolidWorks
      let frustumSize = 10;
      const aspect = window.innerWidth / window.innerHeight;

      const camera = new THREE.OrthographicCamera(
        frustumSize * aspect / -2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        frustumSize / -2,
        0.1,
        1000
      );
      camera.position.set(0, 0, 100);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      const container = document.getElementById('visor-3d');
      const visorWidth = container.clientWidth;
      const visorHeight = container.clientHeight;
      renderer.setSize(visorWidth, visorHeight);
      document.getElementById('visor-3d').appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.enablePan = true;

      // Luces tipo SolidWorks
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); 
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);

      // Grupo para barras + líneas
      let barrasGroup = new THREE.Group();
      scene.add(barrasGroup);

      // Materiales globales para reutilizar
      const material = new THREE.MeshStandardMaterial({
        color: 0xE6E6E6,
        metalness: 0.4,
        roughness: 0.3,
      });
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

      // Actualizar cámara si cambias frustumSize o aspecto
      function updateCamera(distancia) {
        document.getElementById('visor-3d').style.display = 'block';

        // Después de mostrarlo, actualiza el tamaño del renderer
        const container = document.getElementById('visor-3d');
        const width = container.clientWidth;
        const height = container.clientHeight;

        renderer.setSize(width, height);
        camera.aspect = width / height;

        if (distancia/15 > camera.aspect) {
          frustumSize = distancia;
          camera.left = -frustumSize / 2;
          camera.right = frustumSize / 2;
          camera.top = frustumSize / (2 * camera.aspect);
          camera.bottom = -frustumSize / (2 * camera.aspect);
        } else {
          frustumSize = distancia;
          camera.left = -frustumSize * camera.aspect/ 2;
          camera.right = frustumSize * camera.aspect/ 2;
          camera.top = frustumSize / 2;
          camera.bottom = -frustumSize / 2;
        }
        
        camera.updateProjectionMatrix();
        camera.lookAt(0, 0, 0);
      }

      // Función para limpiar barras anteriores y crear nuevas
      function iniciarThreeJS(centro, espesor) {
        // Elimina barras antiguas
        while (barrasGroup.children.length > 0) {
          const obj = barrasGroup.children.pop();
          obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
          barrasGroup.remove(obj);
        }

        const geometry = new THREE.BoxGeometry(espesor, 10, 1);

        // Barras del centro
        centro.forEach(barra => {
          const posX = barra;
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(posX, 0, 0);
          barrasGroup.add(mesh);
          const edges = new THREE.EdgesGeometry(geometry);
          const line = new THREE.LineSegments(edges, lineMaterial);
          line.position.copy(mesh.position);
          barrasGroup.add(line);
        });

        const largoBarandal = centro[centro.length - 1] - centro[0] + espesor; 
        const geometryHorizontal = new THREE.BoxGeometry(largoBarandal, espesor, 1); // larga y delgada

        const barraSuperior = new THREE.Mesh(geometryHorizontal, material);
        barraSuperior.position.set(0, 5 + espesor / 2, 0); // altura = mitad de 10
        barrasGroup.add(barraSuperior);
        // Líneas negras
        const edgesSup = new THREE.EdgesGeometry(geometryHorizontal);
        const lineSup = new THREE.LineSegments(edgesSup, lineMaterial);
        lineSup.position.copy(barraSuperior.position);
        barrasGroup.add(lineSup);

        const barraInferior = new THREE.Mesh(geometryHorizontal, material);
        barraInferior.position.set(0, - 5 - espesor / 2, 0); // altura = mitad de 10
        barrasGroup.add(barraInferior);
        // Líneas negras
        const edgesInf = new THREE.EdgesGeometry(geometryHorizontal);
        const lineInf = new THREE.LineSegments(edgesInf, lineMaterial);
        lineInf.position.copy(barraInferior.position);
        barrasGroup.add(lineInf);

        const textPos = centro.slice(1,-1);
        const posicionLado = getPosiciones("centro");
        const loader = new FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
          for (let i = 0; i < textPos.length; i++) {
            const texto = posicionLado[i][posicionLado[i].length - 1].toString();
            const partes = texto.trim().split(' ');
              const geometry = new TextGeometry(partes[0], {
                font: font,
                size: 0.5,
                height: 0.1,
              });

            const material = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(textPos[i] - 0.5, -8, 0.5);

            barrasGroup.add(mesh); // esto hará que el texto rote con el barandal
            if (partes.length > 1) {
              const partesSub = partes[1].trim().split('/');
              const geometryUp = new TextGeometry(partesSub[0], {
                font: font,
                size: 0.3,
                height: 0.1,
              });

              const material = new THREE.MeshStandardMaterial({ color: 0x333333 });
              const meshUp = new THREE.Mesh(geometryUp, material);
              meshUp.position.set(textPos[i] + 0.5 * (partes[0].length - 1), -7.5, 0.5);

              barrasGroup.add(meshUp); // esto hará que el texto rote con el barandal

              const geometryDown = new TextGeometry(partesSub[1], {
                font: font,
                size: 0.3,
                height: 0.1,
              });

              const meshDown = new THREE.Mesh(geometryDown, material);
              meshDown.position.set(textPos[i] + 0.5 * (partes[0].length - 1), -8, 0.5);

              barrasGroup.add(meshDown); // esto hará que el texto rote con el barandal
            } 
            // Puntos de la línea (vertical de Y = -5 a Y = 5)
            const points = [];
            points.push(new THREE.Vector3(textPos[i], -6.5, 0.5));
            points.push(new THREE.Vector3(textPos[i], -4, 0.5));

            // Geometría
            const geometryLine = new THREE.BufferGeometry().setFromPoints(points);

            // Material punteado
            const materialLine = new THREE.LineDashedMaterial({
              color: 0xff0000,   // rojo
              dashSize: 0.5,     // longitud del trazo
              gapSize: 0.2,      // espacio entre trazos
              linewidth: 1       // nota: no todos los navegadores respetan esto
            });

            // Línea
            const line = new THREE.Line(geometryLine, materialLine);
            line.computeLineDistances(); // IMPORTANTE para que se vean los trazos

            // Agrega a la escena o grupo
            scene.add(line);
          } 
            
        });

        
      }

      // Animación (única vez)
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.iniciarThreeJS = iniciarThreeJS;
      window.updateCamera = updateCamera;

    </script>
    <br>
    <div id="code-qr"><img src="img/frame.png" alt="code QR"></div>

</body>
</html>
